<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-list/iron-list.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-styles/typography.html">
<link rel="import" href="../iron-scroll-threshold/iron-scroll-threshold.html">
<!--
A `<history-list-items>` element renders a list of fistory items.

It should be used in a ARC requests history list view.

## Example
```
<history-list id="history" items="[[list]]"></history-list>
```
The `list` attribute is a list of requests to display.
The `list` will not change from the inside of the element and every state
change is informed via events.

It is safe to load a lot of results into the list. This element uses
the `iron-list` element that renders only a potion of items  to fit
available space.

## Adding pagination
Simplest solution is just to override the `items` array with new values.
It will cause list reset though and it will jump to fisrt element.
To avoid it you can use element's `addItems` function.
However the element will not notify back change in the list so other elements
or app will not notice element's array change.

To avoid this update the array of items as follows:
```
const newItems = new Array(100);
newItems.forEach((i) => this.push('existingItems', i));
```
It will push new elements - one by one - to the end of the array and notify
paths each time the new element will be added.

### Styling
`<history-list-items>` provides the following custom properties and mixins for styling:

Custom property | Description | Default
----------------|-------------|----------
`--history-list-items-element` | Mixin to be applied to the element itself | `{}`
`--history-list-items` | Mixin applied to each list item | `{}`
`--history-list-items-url` | Mixin applied to the URL display element. Note that it is a inline element. | `{}`
`--history-list-items-method` | Mixin applied to the method display element. Note that it is a inline element. | `{}`
`--history-list-items-height` | Height of the list item. | `60px`
`--history-list-items-background-color` | Background color of the list. | `transparent`
`--history-list-items-selected-background-color` | Selection color for list items. | `#E0E0E0`
`--history-list-items-meta-row-color` | Font color of the bottom "meta" row (the one with time information.) | `#757575`
`--history-list-items-meta-row-font-size` | Font size of the bottom "meta" row (the one with time information.) | `12px`
`--history-list-items-open-background-color` | Background color of the "open" button. | `#1E88E5`
`--history-list-items-open-color` | Font color of the "open" button. | `white`

You can style checkbox with paper-checkbox styles like:
```
:host {
  --paper-checkbox-checked-color: #1E88E5;
}
```

@group UI Elements
@element history-list-items
@demo demo/index.html
-->
<dom-module id="history-list-items">
  <template>
    <style>
     :host {
      display: block;
      height: 100vh;
      display: flex;
      flex-direction: column;
      /*--paper-checkbox-checked-color: #1E88E5;*/
      @apply(--history-list-items-element);
    }

    .history-item {
      @apply(--layout-horizontal);
      @apply(--layout-center);
      @apply(--paper-font-body1);
      font-size: 14px;
      height: var(--history-list-items-height, 60px);
      background-color: var(--history-list-items-background-color, transparent);
      @apply(--history-list-items);
    }

    .history-item.selected {
      background-color: var(--history-list-items-selected-background-color, #E0E0E0);
    }

    .checkbox-column {
      @apply(--layout);
      @apply(--layout-center-center);
      height: 48px;
      width: 48px;
    }

    .data-column {
      @apply(--layout-vertical);
      @apply(--layout-flex);
      min-width: 0;
    }

    .url-method-row {
      @apply(--layout-horizontal);
    }

    .method {
      margin-right: 8px;
      @apply(--history-list-items-method);
    }

    .url {
      @apply(--layout-flex);
      @apply(--paper-font-common-nowrap);
      @apply(--history-list-items-url);
    }

    .meta-row {
      color: var(--history-list-items-meta-row-color, #757575);
      font-size: var(--history-list-items-meta-row-font-size, 12px);
    }

    .action-column {
      @apply(--layout-horizontal);
    }

    .open-action {
      background-color: var(--history-list-items-open-background-color, #1E88E5);
      color: var(--history-list-items-open-color, white);
    }

    .group-header {
      font-weight: bold;
      border-bottom: 1px solid #ddd;
      color: #333;
      margin-top: 20px;
      padding: 15px 12px;
    }

    iron-list {
      flex: 1 1 auto;
    }
    </style>
    <iron-list id="list" items="[[items]]" selected-items="{{selectedItems}}" multi-selection selection-enabled>
      <template>
        <div>
          <div class="group-header" hidden$="[[!item.hasHeader]]">[[item.header]]</div>
          <div class$="[[_computeRowClass(selected)]]" tabindex$="[[tabIndex]]" aria-label$="Select/Deselect [[item.url]]">
            <div class="checkbox-column">
              <paper-checkbox on-tap="_toggleCheckbox" checked="[[selected]]"></paper-checkbox>
            </div>
            <div class="data-column">
              <div class="url-method-row">
                <span class="method">{{item.method}}</span>
                <span class="url">{{item.url}}</span>
              </div>
              <div class="meta-row">
                <span class="time">[[_computeHistoryTime(item.updated)]]</span>
              </div>
            </div>
            <div class="action-column">
              <paper-button on-tap="_deleteItem">delete</paper-button>
              <paper-button class="open-action" on-tap="_navigateItem">open</paper-button>
            </div>
          </div>
        </div>
      </template>
    </iron-list>
    <iron-scroll-threshold id="scrollTheshold" lower-threshold="[[threshold]]" on-lower-threshold="_thresholdReached" scroll-target="list">
    </iron-scroll-threshold>
  </template>
  <script>
  Polymer({
    is: 'history-list-items',
    /**
     * Fired when the user clicked on a delete button on an item.
     *
     * @event history-list-item-delete
     * @param {Object} item An object associated with this item.
     * @param {Number} index Object's index in the list.
     */
    /**
     * Fired when the user clicked on an open button on an item.
     *
     * @event history-list-item-open
     * @param {Object} item An object associated with this item.
     * @param {Number} index Object's index in the list.
     */
    /**
     * Fired when the user nearly scrolled to the ened of the list.
     * It usually means that the app should load more results.
     *
     * @event history-list-threshold
     */
    /**
     * Fired when the selection of an item changed.
     *
     * @event history-list-item-selection-changed
     * @param {Object} item An object associated with this item.
     * @param {Number} index Object's index in the list.
     * @param {Boolean} selected True if the item is currently being selected.
     * This mey not yet be reflected in other object states since this event
     * is fired while selection is happening.
     */
    properties: {
      // The list of history items to render.
      items: {
        type: Array,
        value: function() {
          return [];
        }
      },
      // List of selected items on the list.
      selectedItems: {
        type: Array,
        notify: true
      },
      /**
       * A list lower treshold when the `history-list-threshold` will be
       * fired. It should informa the app that the user nearly reached
       * the end of the list and new items should be loaded.
       */
      threshold: {
        type: Number,
        value: 80
      },
      /**
       * If true, the user selected some elements on list. Check the
       * `this.selectedItems` property to check for the selected elements.
       */
      hasSelection: {
        type: Boolean,
        value: false,
        computed: '_computeHasSelection(selectedItems.length)',
        notify: true
      },
      /**
       * If set meanins that the input data has grouping.
       * Each group will display a header and date will be limited to time only.
       * Header should display date for the group.
       *
       * Group item (first item of the group) should have `hasHeader` property set to `true`
       * and `header` property as a header label.
       */
      hasGrouping: {
        type: Boolean
      }
    },

    observers: [
      '_sizeChanged(items.length)'
    ],
    listeners: {
      'iron-select': '_onSelectItem',
      'iron-deselect': '_onSelectItem',
      'iron-activate': '_onSelectItem',
      'iron-changed': '_onSelectItem',
      'iron-change': '_onSelectItem'
    },
    hostAttributes: {
      'role': 'list'
    },

    _sizeChanged: function(length) {
      if (length) {
        this.async(() => {
          // this.$.list.notifyResize();
          this.$.scrollTheshold.clearTriggers();
        }, 2);
      }
    },

    _computeHistoryTime: function(timestamp) {
      var d = new Date(Number(timestamp));
      var options = {
        // year: 'numeric',
        // month: 'numeric',
        // day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        // second: 'numeric'
      };
      return new Intl.DateTimeFormat(undefined, options).format(d);
    },

    _computeRowClass: function(selected) {
      var clazz = 'history-item';
      if (selected) {
        clazz += ' selected';
      }
      return clazz;
    },

    _deleteItem: function(e) {
      this.fire('history-list-item-delete', {
        item: e.model.get('item'),
        index: e.model.get('index')
      });
    },

    _navigateItem: function(e) {
      this.fire('history-list-item-open', {
        item: e.model.get('item'),
        index: e.model.get('index')
      });
    },

    _thresholdReached: function() {
      this.fire('history-list-threshold');
    },

    _computeHasSelection: function(length) {
      return !!length;
    },
    _toggleCheckbox: function(e) {
      this.$.list.toggleSelectionForItem(e.model.index);
    },
    /**
     * Use this method to add new items to the `items` array.
     * It will prohibit list jumping while changing the list object manually
     *
     * @param {Array} items List of items to add.
     */
    addItems: function(items) {
      if (!items || !items.length) {
        return;
      }
      items.forEach((i) => this.push('items', i));
    },

    _onSelectItem: function(e) {
      e = Polymer.dom(e);
      var model = this.$.list.modelForElement(e.rootTarget);
      this.fire('history-list-item-selection-changed', {
        item: model.get('item'),
        index: model.get('index'),
        selected: this.selectedItems.indexOf(model.get('item')) === -1
      });
    }
  });
  </script>
</dom-module>
